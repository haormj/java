# 工厂模式
概念:定义一个用户创建对象的接口,让子类决定实例化哪一个类.工厂方法使影类的实例化延迟到其子类.

分类:
  - 简单工厂模式
  - 工厂方法模式
  - 抽象工厂模式

工厂模式就是为了创建其他类例而产生的.例如,现在我有一个车接口,下面有很多实现类,在不同的时候,我可能会创建不同的车对象,在这种情况下面,我们就可以使用工厂模式来实现.

正如上面的分类一样

1. 如果我们直接写一个car的工厂类,那么就是第一种类型,在其中对现在所有的car具体类型进行判断,从而返回用户想要的类型.
2. 在就是写一个抽象工厂,然后具体工厂继承抽象工厂,在具体工厂里面,分别实例不同的产品对象,最后我们在实例化工厂的时候,可以使用多态来实例我们指定的产品对象.
3. 还有一种情况就是有多个抽象产品.例如:老师,学生;虽然他们都是人,但是就目前而言老师和学生也是抽象的,从而在为这个产品写工厂类的时候,我们一个抽象工厂类中年需要实例两个对象,从而继承抽象工厂的子类,也要实现多个方法.

上面就是我对工厂模式的理解,其实也就是这个意思,他们的的角色有产品和工厂,工厂负责生产产品,至于如何组织工厂和产品就出现了分类.

- 简单工厂

        具体工厂+抽象产品+具体产品--所有的实例化都是由这个工厂负责.
- 工厂方法

        抽象工厂+具体工厂+抽象产品+具体产品--具体的实例化交给具体工厂来做.
- 抽象工厂

        抽象工厂+具体工厂+多个抽象产品+具体产品--相对工厂方法成为了多个抽象产品
## 举例
我这里写了一个工厂方法模式的例子,具体如下:

- [Creator.java](./Creator.java):工厂接口
- [ConcreteCreator.java](./ConcreteCreator.java):具体工厂实现,这里面我使用了泛型,从而避免了出现多个具体工厂.
- [Product](./Product.java):产品接口
- [ConcreteCreator.java](./ConcreteCreator.java):具体产品,我只是写了一个实现类
- [Main.java](./Main.java):程序入口类
